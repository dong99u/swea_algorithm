import sys

sys.stdin = open('input.txt')

'''전제
    BST(이진 탐색 트리)의 중위 순회 결과는 오름차순 정렬된 값의 나열이다.
    이 때, 완전 이진 트리에 1부터 N까지의 값을 중위 순회 방식으로 채웠을 때,
    즉, L번째 노드의 값은 왼쪽 서브트리의 노드 개수 + 1 이다.)

    예를 들어, N=10일 때,
                    1
                /       \
               2           3
             /   \       /   \
            4      5    6     7
          / \    /
         8  9  10
    - 루트 노드(1)의 값은 왼쪽 서브트리의 노드 개수 5 + 1 = 6
    - 노드 2의 값은 왼쪽 서브트리의 노드 개수 3 + 1 = 4

    이 규칙에 맞춰 완전 이진트리에 중위순회하여 1부터 N까지의 값을 채웠을 때,
                    7
                /       \
               4           9
             /   \       /   \
           2       6    8     10
          / \    /
         1   3  5   
    리스트로 표현하면, (0번 인덱스는 사용하지 않음)
    index: 0 1 2 3 4 5 6  7 8 9 10
    value: 0 7 4 9 2 6 8 10 1 3 5

    따라서, K번째 노드의 값은

    각 노드에서 왼쪽 서브트리의 노드 개수를 누적 합산한 값 + 1 이다.
    K 까지의 경로를 따라가며 왼쪽/오른쪽 이동을 판단하고,
    왼쪽으로 이동할 때는 서브트리의 노드 개수만큼,
    오른쪽으로 이동할 때는 서브트리의 노드 개수 + 1(루트) 만큼을 누적 합산한다.

    예를 들어, N=10이고 K=5일 때,
    - K=5까지: 1 -> 2 -> 5
        1. 1에서 2로 이동: 왼쪽 이동이므로, offset += 0 (왼쪽 서브트리 노드 개수)
        2. 2에서 5로 이동: 오른쪽 이동이므로, offset += 3 + 1 (왼쪽 서브트리 노드 개수 + 1)
    - 따라서, K=5의 값은 offset 4 + 왼쪽 서브트리 노드 개수 0 + 1 = 5   

'''


# 왼쪽 서브트리의 노드 개수 계산
# 1. 완전 이진트리 높이를 먼저 구한다.
# 2. 마지막 레벨을 제외한 나머지 레벨의 왼쪽 서브트리 노드 개수를 구한다.
# 3. 마지막 레벨의 왼쪽 서브트리 노드 개수를 구한다.
def left_size(n):
    if n <= 0:
        return 0
    if n == 1:
        return 0
    # 루트 레벨 1 기준 높이 H
    '''
        h = 3
        bin(h) -> 11 >>> 2
          1     1
         / \
        2   3   2
    '''
    h = n.bit_length()
    # f(n) 공식 적용
    '''
        왼쪽 서브트리의 완전 이진트리 노드 개수
        h = 4 라고 해보자
                    1               1
                /       \
               2           3        2
             /   \       /   \
            4      5    6     7     3
          / \    /
         8  9  10                   4

        루트를 기준으로 왼쪽 서브 트리의 높이는 h-1.
        - 이때, 마지막 레벨은 노드의 개수가 꽉 차지 않을 수 있다.
        - 따라서, 마지막 레벨을 제외한 나머지 레벨의 노드 개수와
          마지막 레벨의 노드 개수를 분리해서 생각해보자.

        먼저, (h-1)레벨까지의 완전 이진트리 노드 개수를 구해보자.
        = 1 + 2 + 4 + ... + 2^(h-2)
        = 2^(h-1) - 1
        = (1 << (h - 1)) - 1


        그 중, 왼쪽 서브트리의 노드 개수는?
        (2^(h-1) - 1) // 2  # 전체 노드 개수의 절반 (루트 제외)
        = 2^(h-2) - 1 
        = (1 << (h - 2)) - 1


        남은 노드 개수는
        전체 노드수 - (마지막 레벨을 제외한 나머지 레벨의 노드 개수)
        = n - (2^(h-1) - 1)
        = n - ((1 << (h - 1)) - 1)


        이제 마지막 레벨의 왼쪽 서브트리 노드 개수를 구해보자.
        마지막 레벨의 노드 개수는 최대 2^(h-1)개 이다. (1 << (h - 1))
        그 중, 왼쪽 서브트리의 마지막 레벨 노드 개수는 최대 2^(h-2)개 이다.
        즉, 
        = min(남은 노드 개수, 2^(h-2))
        = min(remaining, 1 << (h - 2))
    '''
    # 왼쪽 서브트리의 마지막 레벨을 제외한 나머지 레벨의 노드 개수
    full_left = (1 << (h - 2)) - 1
    # 남은 노드 개수
    remaining = n - ((1 << (h - 1)) - 1)
    # 왼쪽 서브트리의 마지막 레벨 노드 개수
    left_extra = min(remaining, 1 << (h - 2))
    return full_left + left_extra


def cal(N, K):
    # 1. 루트에서 K까지의 경로 생성
    # (예: K=6 -> [6, 3, 1] -> [1, 3, 6])
    path = []
    temp = K
    while temp >= 1:
        path.append(temp)
        temp //= 2
    path.reverse()

    # 2. 경로를 따라가며 값 계산
    curr_n = N  # 현재 서브트리의 노드 개수
    offset = 0  # 누적된 왼쪽 서브트리 노드 개수 합산 값

    # 2. 경로를 따라 내려가며 offset 계산
    for i in range(len(path) - 1):
        L = left_size(curr_n)
        if path[i + 1] == path[i] * 2:  # 왼쪽 이동 / 1 == 3?
            curr_n = L  # 왼쪽 서브트리로 이동
        else:  # 오른쪽 이동
            offset += (L + 1)  # 왼쪽 서브트리 노드 개수 + 1(루트)
            curr_n = curr_n - L - 1  # 오른쪽 서브트리로 이동

    # 3. 최종 목적지 K의 값 계산
    return offset + left_size(curr_n) + 1


T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    print(f'#{tc} {cal(N, 1)} {cal(N, N // 2)}')